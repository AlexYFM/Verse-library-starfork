
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Parser &#8212; verse 0.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script src="_static/jquery.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Simulations" href="outputs.html" />
    <link rel="prev" title="Scenario" href="scenario.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="parser">
<h1>Parser<a class="headerlink" href="#parser" title="Permalink to this heading"></a></h1>
<section id="goals">
<h2>Goals<a class="headerlink" href="#goals" title="Permalink to this heading"></a></h2>
<p>The primary goal of the parser is to obtain single expressions for different parts of the system, so that it’s easier for the backend system to do analysis. Since we use a SAT solver (z3) in the backend for checking if a guard in the controller is activated, a single expression would allow us to convert the expression directly into a z3 expression and the satisfiability is checked once.</p>
</section>
<section id="working-principle">
<h2>Working Principle<a class="headerlink" href="#working-principle" title="Permalink to this heading"></a></h2>
<p>The parser achieves this by using a simple AST walking interpreter on the input file, with a list of scoped environments to keep track of the values of the variables. The only difference to normal interpreters being that the values of the variables are the ASTs themselves, i.e. no evaluation is done on the ASTs. When the variables are used, the ASTs they contain are substituted into the larger AST they are in. Functions and lambdas work essentially the same way, with the body of the function/lambda substituted with the arguments’ ASTs (functions and lambdas actually use the same value augmented to the Python AST i.e. <code class="docutils literal notranslate"><span class="pre">Lambda</span></code>)</p>
<p>Since the values can only be some form of Python AST (or custom values, as explained below), no builtin functions/variables are supported other than the ones mentioned in <a class="reference internal" href="#Reductions"><span class="xref myst">Reductions</span></a>. Imported modules are also not processed. They are treated as <code class="docutils literal notranslate"><span class="pre">Hole</span></code>s in the environments, i.e. valid defined symbols but the parser knows nothing more about them. Functions that are called as a member of a module or of a variable are preserved and not expanded, as they may be supported by the backend. The use of any other functions will cause an error.</p>
<p>In order to simplify backend processing, there are 2 new values introduced into the AST (in addition to lambdas), <code class="docutils literal notranslate"><span class="pre">CondVal</span></code>s and <code class="docutils literal notranslate"><span class="pre">Reduction</span></code>s.</p>
<section id="conditional-values">
<h3>Conditional Values<a class="headerlink" href="#conditional-values" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">CondVal</span></code>, or conditional values, are used as the primary analysis component for the backend. They store a list of all the possible values a variable can take, as well as the conditions that needs to be met for the values to be taken (i.e. a list of <code class="docutils literal notranslate"><span class="pre">CondValCase</span></code>s). In each case, the list of conditions are implicitly <code class="docutils literal notranslate"><span class="pre">and</span></code>ed together.</p>
<p><code class="docutils literal notranslate"><span class="pre">CondVal</span></code>s are constructed when a variable is assigned in a if statement somewhere in the code. When a variable is assigned multiple times in different if statements (or different branches of them), the value will be “merged” together using the test condition. Simply, when a merge happens, the test condition is appended to the list of conditions for each value in the <code class="docutils literal notranslate"><span class="pre">CondVal</span></code>, and if the value is assigned in an else branch, the test is inverted.</p>
<p>Due to how the execution uncertainty is checked in the backend, the parser also doesn’t follow the usual semantics of how <code class="docutils literal notranslate"><span class="pre">if</span></code> statements work. Consider this snippet:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">42</span>
<span class="k">if</span> <span class="n">test</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>The parser will actually report that <code class="docutils literal notranslate"><span class="pre">a</span></code> could be <code class="docutils literal notranslate"><span class="pre">42</span></code> whenever (no condition needed to trigger) and <code class="docutils literal notranslate"><span class="pre">3</span></code> when <code class="docutils literal notranslate"><span class="pre">test</span></code> is satisfied. In a normal python execution, <code class="docutils literal notranslate"><span class="pre">a</span></code> will only be <code class="docutils literal notranslate"><span class="pre">42</span></code> if <code class="docutils literal notranslate"><span class="pre">test</span></code> is not satisfied (unless the evaluation of <code class="docutils literal notranslate"><span class="pre">test</span></code> causes an exception).</p>
</section>
<section id="reductions">
<h3><a name="Reductions"></a>Reductions<a class="headerlink" href="#reductions" title="Permalink to this heading"></a></h3>
<p>Due to the need to support multiple agents, it’s necessary to have support for some form of reductions, since the control output will only be one “thing”. Arbitrary loops are hard to support, since they can have arbitrary control flow that are hard to analyze. Instead, we support builtin reduction functions (currently only <code class="docutils literal notranslate"><span class="pre">all</span></code> and <code class="docutils literal notranslate"><span class="pre">any</span></code>) called on generator comprehension expressions. These are much better formed and easier to process. When the parser encounters a call like <code class="docutils literal notranslate"><span class="pre">all(test(o)</span> <span class="pre">for</span> <span class="pre">o</span> <span class="pre">in</span> <span class="pre">other_states)</span></code> it’ll convert that into a <code class="docutils literal notranslate"><span class="pre">Reduction</span></code> value, which will then be unrolled in reachtube computation with the sensor values, or converted back to a normal Python function call to be evaluated in simulation.</p>
</section>
</section>
<section id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>Very limited function definition support</p></li>
<li><p>Basically no support for imported modules</p></li>
<li><p>No loops allowed in the code, instead only specific reduction calls are supported</p></li>
<li><p>Unusual if statement semantics</p></li>
<li><p>Only one return statement is supported per function, and it has to be at the end</p></li>
<li><p>State definitions are inferred from the variable type definitions in the class that end in <code class="docutils literal notranslate"><span class="pre">State</span></code>, and the type (discrete/continuous) of the member variable is determined from the name; no method definition is used</p></li>
<li><p>Similar to how states are processed, discrete modes are also class definitions with names ending in <code class="docutils literal notranslate"><span class="pre">Mode</span></code>, and the declaration is assumed to be how <code class="docutils literal notranslate"><span class="pre">enum.Enum</span></code> is usually used; see demos for examples. No method definition is used</p></li>
<li><p>Custom class definitions (other than the states and modes definitions) are not processed</p></li>
</ul>
<p>Some of these may be resolved later, others stem from the limitations of some of the analysis methods and backends (e.g. z3)</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">verse</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="creating_scenario_in_verse.html">Creating Scenario in Verse</a></li>
<li class="toctree-l1"><a class="reference internal" href="agent.html">Agent</a></li>
<li class="toctree-l1"><a class="reference internal" href="map.html">Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="sensor.html">Sensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="scenario.html">Scenario</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Parser</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#goals">Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-principle">Working Principle</a></li>
<li class="toctree-l2"><a class="reference internal" href="#limitations">Limitations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="outputs.html">Simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="outputs.html#reachtubes">Reachtubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html">Contributors</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/verse.html">verse</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="scenario.html" title="previous chapter">Scenario</a></li>
      <li>Next: <a href="outputs.html" title="next chapter">Simulations</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Yangge Li, Haoqing Zhu.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/parser.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>